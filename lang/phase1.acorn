// First implementation phase
//  - Basic arithmetic operators and a fixed i64 type.
//  - Essentially no error handling.
19 + (1 * 1 + 78 / 2) / 2 - -3 // 42

// Requirements
// 1. Parse a single expression
// 2. Generate IR for the expression in a contrived main function
// 3. Supported operators
//    infix: + - * /
//    prefix: -
//    parens
// 4. Sufficient testing of parser _and_ generator

// Lexer
// + - * / ( ) NUMBER IDENT COMMENT WHITESPACE
// No queries in lexer, parser query just returns an AST for a file

// Parser
// Pratt parser for now
// Ability to parse a single expression during testing that will stay around

// AST
// Some nice macro for ast generation?
decl_ast! {
    exprs:
    InfixExpr {
        lhs: Expr { code_to_get_it }
        op: InfixOp
        rhs: Expr { code_to_get_it }
    }
}

// HIR
// ...

// Testing
// manual symbol tests for lexer
// expect-test for parser
// TODO AST/HIR
// End-to-end based on a commented acorn file.
// - todo this means that comments sort of need to be accessible, which might cause issues.

// Test file spec
// // type: expr|stmt|default
//    Decides what the upcoming syntax is. The result is wrapped by the appropriate supporting
//      llvm ir to return the value. For example, expr is wrapped with a main fn TODO how to do non int types
//    Only expr is supported in this version
//
// // expect 2
//    Denotes a new test starting here. The following content (until another expect) should evaluate
//      to the given value. TODO Non integer values
// 1 + 1
//