// Planning for the metaprogramming API within Acorn
// Pointers taken from Zig, and my personal opinions about
//  some faults that system has, and untested alternatives.

// As noted previously, concepts such as types themselves are first
//  class to the language, however, only at compile time. At runtime
//  all types are defined and cannot be operated upon.
// In addition to types, functions can be evaluated at compile time.

// Generic types are implemented using compile time methods, see below.
// The function takes an argument T which is of the type `type`, and
//  must be known at compile time (given the comptime keyword). The
//  return value of the function is another type itself.
fn LinkedList(comptime T: type) type {
    return struct {
        item: T,
        next: Option(&LinkedList(T))
    }
}

// This function can then be used at compile time to generate multiple
//  variants of a list, similar to generics in other languages.
const IntList = LinkedList(i32);
const FloatList = LinkedList(f32);


// Any function may be evaluated at compile time if it is pure and calls no
//  runtime-only functions. For example, the following is valid.
fn fib(n: i32) i32 {
    if n < 2 {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

const fib10 = fib(10);

// Note that nothing above is annotated as comptime explicitly. `fib` may
//  also be called at runtime. To make this explicit, a function may be
//  marked as comptime, and it will never be present at runtime.
comptime fn fib_c(n: i32) i32 {
    todo();
}

// Comptime can be used in other places as well, such as most control flow
// This can be used to generate code at runtime, see below.
// Note: `n` must be comptime, since it is used in a compile time context.
fn even_odd(comptime n: i32) {
    // Each iteration will be evaluated as far as possible before encountering a runtime-only expression.
    inline for i in 0..n {
        if i % 2 == 0 {
            println("even");
        } else {
            println("odd");
        }
    }
}

// Calling even_odd(4) would result in the following.
// Note that the if statement was implicitly evaluted at
//  compile time since `i` was known.
fn even_odd_4() {
    println("even");
    println("odd");
    println("even");
    println("odd");
}

// The `_` symbol may be used to instruct the compiler to determine the type on its own.
// For example, given the following function:
fn max(comptime T: type, a: T, b: T) T {
    if a > b {
        return a;
    } else {
        return b;
    }
}

// The following are equivalent
max(i32, 1, 2);
max(_, 1i32, 2);
// Multiple things are happening here automatically:
// 1. The type of `1i32` is i32 (specified by the trailing i32)
// 2. The type of `2` is comptime_int, which may be implicitly cast to i32
// 3. The compiler is instructed to infer the type of `a` and `b`. It uses
//    the most restrictive of the two. In this case, i32.
// 4. 2 is implicitly converted to an i32 according to previous note.



// SECTION: Experimental Syntax
//  TODO better examples needed before committing to this or anything alike.
// It is sometimes beneficial to allow metaprogramming that returns syntax in place,
//  for example, consider the following (admittedly stupid) Rust macro.

// macro_rules! say_number {
//     (num:expr) => { println!(num); };
// }
//
// fn main() {
//     say_number!(2);
//     // Expands to
//     println!(2);
// }

// Instead of returning a value, the macro is replaced by raw syntax.
// The solution in Acorns universe of metaprogramming is an `inline` comptime function
// For example, the following mimics the `say_hello` macro above.
inline comptime fn say_number(n: i32) {
    println();
}

// Inline comptime functions present a few key differences.
// todo this is the same behavior as any other comptime function evalution, except that it inlines the body (as you would expect)
//      see the even_odd example above.
// 1. They do not throw a compile time error when performing runtime-only operations.
// 2. They may have a mix of comptime and runtime-known parameters.
// 3. Any runtime-only expressions inside are left behind after compilation

//TODO: Some remaining questions

// What do I do if I want to define a struct for example. Consider the following:
inline comptime fn define_a_point() {

    const Point = struct {
        x: i32,
        y: i32,
    }

}

// The goal is for the Point definition to remain in place, but according to the
//  previous rules the Point will not be left behind since it may be evaluated at
//  compile time.
// The introduction of some way to instruct the compiler to leave a value behind
//  is required.
// 1. dyn: "dynamic", aka tells the compiler that the value should not be evaluated away
// 2. runtime: opposite of comptime
inline comptime fn define_a_point() {
    runtime const Point = struct {
        x: i32,
        y: i32,
    }
}

//todo this whole system seems awful. I think either you cannot do this, or you can return a namespace from a comptime function, which can be absorbed with something like zig usingnamespace.
// eg
comptime fn define_a_point() ns {
    return ns {
        const Point = struct {
            x: i32,
            y: i32,
        }
    }
}

use define_a_point();
const p = define_a_point();

// later
Point {
    x: 1,
    y: 2,
}

p.Point {
    x: 1,
    y: 2,
}

//todo in this case i dont believe there is a difference between a namespace and a struct with zero fields.
//todo is a file implicitly a struct/namespace?


























